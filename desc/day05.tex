Well, today's solution is nothing to be proud of, unfortunately ran out of time. Regardless, the performance is luckily not prohibitively terrible. If I can, I would like to return to this and solve it in an optimal way. A basic version would test all segments against each other and record intersections in a set. However, at least for part 1, there should be a solution that runs in $\mathcal{O}(n \log n + k)$, where $k$ is the number of intersections. This requires a self-balancing binary tree (e.g. a red-black tree) and would be based on the solution described <a href="https://people.scs.carleton.ca/~michiel/lecturenotes/ALGGEOM/horverintersect.pdf" target="_blank">here</a> and <a href="https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm" target="_blank">here</a>. It needs some modifications, because on its own it will not count the intersections of two horizontal or two vertical lines. I reckon I got 90% to the solution, but unfortunately things got a little out of hand trying to handle these special cases. So for now, we get the brute-force solution. Wheee!
<br><br>
Luckily, the brute-force version also directly works for part 2. I am not sure if an elegant solution can be done for all three line types simultaneously or how much overhead that would be. I would be happy to learn about any highly efficient solutions that I perhaps did not consider.