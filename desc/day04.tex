For this day, it appears to be a rather atypical game of Bingo. The numbers are not limited by the columns they are in, as is standard, and the range of numbers goes beyond the usual $1-75$. So we must assume that in this game, any number can go anywhere on the board. Hence, we cannot preallocate memory for an index that would tell us which number exists where on which board. Our best bet is a map. We could go over all the boards and create such an index from $(number) \rightarrow [(board, col, row), ...]$ entries. If each row and column starts with $5$ remaining numbers, we can then run through the numbers being drawn and strike them off, updating the counts board's row and column. Creating the index would require reading the entire input and updating the map and array. If inserting and retrieving numbers in the map is considered $\mathcal{O}(1)$, which is kinda true for hash maps (let's not open up that can of worms), the run time would be $\mathcal{O}(m + n)$. However, the memory consumption for this map would be $\mathcal{O}(m \times n)$. 
<br><br>
There is a more compact alternative: we can first build a map over the inputs $number \rightarrow draw$ instead. As we then iterate over the entries in each board, which we would have to do anyway, can simply check if the entry exists in the map. 
The filed consists then of information regarding the values and when they were drawn. Each row/column then detects when it is first won and tries to update the earliest win for the board. In an ideal world (maps implemented as hash maps, etc...), every individual operation of this solution requires $\mathcal{O}(1)$ per input element (drawn numbers + board numbers). Hence for $m$ drawn numbers and $n$ board numbers, the run time should be $\mathcal{O}(m + n)$ and for memory, we only need the map plus constant-sized storage for the contents of a single board, i.e., $\mathcal{O}(m)$, which seems ideal. 