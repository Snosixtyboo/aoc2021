For this day, it appears to be a rather atypical game of Bingo. The numbers are not limited by the columns they are in, as is standard, and the range of numbers goes beyond the usual $1-75$. So we must assume that in this game, any number can go anywhere on the board. Hence, we cannot preallocate memory for an index that would tell us which number exists where on which board. Our best bet is a map. We could go over all the boards and create such an index from $(number) \rightarrow [(board, col, row), ...]$ entries. If each row and column starts with $5$ remaining numbers, we can then run through the numbers being drawn and strike them off, updating the counts board's row and column. Creating the index would require reading the entire input and updating the map and array. If inserting and retrieving numbers in the map is considered $\mathcal{O}(1)$, which is kinda true for hash maps (let's not open up that can of worms), the runtime would be $\mathcal{O}(m + n)$. However, the memory consumption for this map would be $\mathcal{O}(m \times n)$. There is a more compact alternative: we can first build a map over the inputs $number \rightarrow draw$ instead. As we then iterate over the entries in each board, which we would have to do anyway, can simply check if the entry exists in the map. For each row and column, we maintain the latest draw in which a number was removed and a count of how many are left. If a row or column reaches $0$ remaining numbers, the row/column tries to update the earliest draw for the board in which a win would have occurred with its latest registered draw. In an ideal world (maps implemented as hash maps, etc...), every individual operation of this solution requires $\mathcal{O}(1)$ per input element (drawn numbers + board numbers). Hence for $m$ drawn numbers and $n$ board numbers, the runtime should be $\mathcal{O}(m + n)$ and for memory, we only need the map plus constant-sized storage for the contents of a single board, i.e., $\mathcal{O}(m)$, which seems ideal. 